{
  
    
        "post0": {
            "title": "Numpy",
            "content": "&quot;relancez cette cellule quand vous voulez repartir de zéro&quot; %reset -f import numpy as np . Qu&#39;est-ce? . Les listes python sont extensibles à volonté et peuvent contenir n&#39;importe quoi. On les créer avec les crochets:uneListe=[]. Dans un cadre scientifique, pour des questions de performances, on travaille essentiellement avec numpy qui crée des tenseurs, c.à.d: . des tableaux multi-dimensionnel | de taille fixée | qui ne peuvent contenir qu&#39;un seul type d&#39;objet : int ou float (numpy gère d&#39;autre types, mais on ne les utisera pas) | rapidement manipulable dans leur ensemble (grace à des &quot;boucles implicites&quot;) | . L&#39;ordre ou la dimension d&#39;un tenseur, c&#39;est son nombre d&#39;indices: . tenseur d&#39;ordre 1 = vecteur, ex: pour stocker du son | tenseur d&#39;ordre 2 = matrice, ex: pour stocker une image | tenseur d&#39;ordre 3 = volume, ex: pour stocker une vidéo | tenseur d&#39;ordre 4 = très utile quand on fait du deep-learning sur des images | . On précise l&#39;affichage des tableau numpy : . 3 décimales après la virgule | on supprime la notation scientifique des nombres | on veut de grandes lignes | . np.set_printoptions(precision=3,suppress=True,linewidth=5000) . Type des donn&#233;es . Voici les principaux dtypes (=data-type) que l&#39;on rencontre: . np.float64= flottant sur 64 bit: c&#39;est le dtype par défault pour stocker des valeurs réelles. | np.int64= entier signés sur 64 bits: : c&#39;est le dtype par défault pour stocker des valeurs entière. | np.uint8= entier positifs (unsigned) sur 8 bits: on les obtient quand on importe des images png ou jpeg. Les pixels prennent des valeurs de 0 à 255 | np.float32, np.int32: la bibliothèque tensorflow qui permet de faire du deeplearning est par défaut sur 32 bit: pour économiser de la place mémoire. | . Tableau de flotant . &quot;&quot;&quot;un vecteur initialisé par une liste de valeurs. &quot;&quot;&quot; vec=np.array([1.,2,3,4]) &quot;&quot;&quot;une matrice&quot;&quot;&quot; mat=np.array([ [1.,2,0],[3,4,0]]) &quot;notez qu&#39;on a mis au moins un coefficient flottant (avec un point)&quot; print(&quot;vec n&quot;,vec) print(&quot;mat n&quot;,mat) . vec [1. 2. 3. 4.] mat [[1. 2. 0.] [3. 4. 0.]] . Les principales caractéristiques d&#39;un tableau sont: . dtype = data-type | shape = sa forme | . print(&quot;vec:&quot;,vec.dtype,vec.shape) print(&quot;mat:&quot;,mat.dtype,mat.shape) . vec: float64 (4,) mat: float64 (2, 3) . &quot;&quot;&quot;vecteur de flotant initialisé à 0, matrice de flottant initialisé à 1&quot;&quot;&quot; vec_zero=np.zeros(shape=[5]) mat_un=np.ones(shape=[5,4]) print(&quot; n vec_zero n&quot;,vec_zero) print(&quot; n mat_un n&quot;,mat_un) . vec_zero [0. 0. 0. 0. 0.] mat_un [[1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.]] . Tableau d&#39;entier . Attention, depuis python 3, les indices de tableau doivent nécessairement être des entiers. Par exemple tenseur[3.0] renvoie une erreur. . Du coup, si l&#39;on veut faire un tableau qui contiens plusieurs indices, il faut créer un tableau d&#39;entier. C&#39;est quasiment le seul cas où l&#39;on va utiliser de tels tableaux. . indices=np.array([0,3,1]) vec = np.array([0.,2,4,6,8,10]) print(indices) print(indices.dtype) print(vec[indices]) . [0 3 1] int64 [0. 6. 2.] . &quot;&quot;&quot;convertissons&quot;&quot;&quot; vec=np.array([1.5,2.5,3.5,4.5]) print(vec,&quot; dtype:&quot;,vec.dtype) vec=vec.astype(np.int64) print(vec,&quot; dtype:&quot;,vec.dtype) vec=vec.astype(np.float64) print(vec,&quot; dtype:&quot;,vec.dtype) . [1.5 2.5 3.5 4.5] dtype: float64 [1 2 3 4] dtype: int64 [1. 2. 3. 4.] dtype: float64 . Exo : modifiez $(1 heartsuit)$ le vecteur indices ci-dessus, pour qu&#39;il contienne des flottant. Indiquez le message d&#39;erreur qui en découle. . Op&#233;rations &#233;l&#233;ment par &#233;l&#233;ment . La plupart des opérations sur les tenseurs se font élément par élément à l&#39;aide d&#39;une boucle implicite très rapide. Par exemple tenseur1 * tenseur2 effectue la multiplication terme à terme (et non pas une multiplication matricielle). . Exemples . &quot;&quot;&quot;toutes ces opérations sur les tenseurs sont faites terme à terme.&quot;&quot;&quot; vec = np.array([1., 2, 3, 4]) vec_carre = vec**2 vec2= vec+vec_carre vec3=7*vec vec4=np.sin(vec) vec5=vec2*vec3 print(&quot;vec&quot;,vec) print(&quot;vec_carre&quot;,vec_carre) print(&quot;vec2&quot;,vec2) print(&quot;vec3&quot;,vec3) print(&quot;vec4&quot;,vec4) print(&quot;vec5&quot;,vec5) . vec [1. 2. 3. 4.] vec_carre [ 1. 4. 9. 16.] vec2 [ 2. 6. 12. 20.] vec3 [ 7. 14. 21. 28.] vec4 [ 0.841 0.909 0.141 -0.757] vec5 [ 14. 84. 252. 560.] . Voici un exemple très classique de utilisation d&#39;une fonction numpy . import matplotlib.pyplot as plt x=np.linspace(0,60,1000) y=np.sin(x) plt.plot(x,y); . performances . Comparons les performances entre une boulce implicite et une boucle explicite . a=np.random.randint(0,100,size=1000000) b=np.random.randint(0,100,size=1000000) . %%time &quot;&quot;&quot; %%time : Pour calculez le temps d&#39;une celle entière %time : Pour calculez le temps d&#39;une seule ligne de code &quot;&quot;&quot; &quot;boucle implicite&quot; c=a*b print(&quot;premières valeurs: n&quot;,c[:10]) . premières valeurs: [1649 3339 3772 8188 198 5168 826 215 6004 4884] CPU times: user 4.48 ms, sys: 0 ns, total: 4.48 ms Wall time: 3.74 ms . %%time c=np.empty(len(a)) &quot;boucle explicite&quot; for i in range(len(a)): c[i]=a[i]*b[i] print(&quot;premières valeurs:&quot;,c[:10]) . premières valeurs: [1649. 3339. 3772. 8188. 198. 5168. 826. 215. 6004. 4884.] CPU times: user 582 ms, sys: 929 µs, total: 583 ms Wall time: 588 ms . numpy effectue des copies . La plupart des fonctions numpy ne modifient pas l&#39;argument de départ: une &#39;copie&#39; est faite. . vec = np.array([1., 2, 3, 4]) vec1=vec**2 vec2=np.sin(vec) print(vec.round()) print(vec1) print(vec2) &quot;&quot;&quot;vec n&#39;a pas changer&quot;&quot;&quot; print(&quot;vec&quot;,vec) . [1. 2. 3. 4.] [ 1. 4. 9. 16.] [ 0.841 0.909 0.141 -0.757] vec [1. 2. 3. 4.] . Une exception naturelle: . &quot; ici l&#39;espace mémoire de `vec` est réutilisé pour stocker `2*vec`&quot; vec*=2 print(vec) . [2. 4. 6. 8.] . Syntaxe objet ou fonctionnelle . De nombreuses fonctions numpy peuvent s&#39;utiliser avec deux syntaxes différentes : . np.fonction(tenseur) . | tenseur.fonction() . | Et même dans le second cas, une copie du tenseur est faites ; c&#39;est un peu trompeur car la syntaxe objet tenseur.fonction() suggère en générale une opération modifiant l&#39;objet (opération &quot;inPlace&quot;) . vec = np.array([1.1234, 2.1234, 3.1234, 4.1234]) &quot;&quot;&quot;arrondir&quot;&quot;&quot; vec1= np.round(vec,1) &quot;&quot;&quot;idem avec syntaxe différente&quot;&quot;&quot; vec2= vec.round(1) print(&quot;vec1&quot;, vec1) print(&quot;vec2&quot;, vec2) &quot;&quot;&quot;vec n&#39;a pas changer (cependant il ne s&#39;affiche qu&#39;avec 3 décimales à cause de notre entête)&quot;&quot;&quot; print(&quot;vec&quot;, vec) . vec1 [1.1 2.1 3.1 4.1] vec2 [1.1 2.1 3.1 4.1] vec [1.123 2.123 3.123 4.123] . Exo . Pensez à utiliser la complétion automatique pour voir quelles sont les fonctions disponibles. Par exemple tapez np.a suivit de la touche tabualtion. Utilisez cela pour tracer les fonctions . arccosinus $(1 heartsuit)$ | arctangeante $(1 heartsuit)$ | la partie entière (il faut savoir dire &quot;sol&quot; en anglais) $(1 heartsuit)$ | cosinus hyperbolique $(1 heartsuit)$ | logarithme népérien $(1 heartsuit)$ | logarithme en base 10 $(1 heartsuit)$ | . Retenez aussi une fonction particulière : np.arctan2(x,y) qui permet de renvoyer l&#39;angle alpha du point de coordonnée (x,y) . Jouer avec les axes $ flat$ . Pour les tenseurs de dimension $ geq 2$, on peut faire des opérations en suivant un axe donnée. Commençons par observer cela sur des matrices (dim=2). . lignes et colonnes . La convention pour numéroter les lignes et les colonnes est la même qu&#39;en mathématiques . mat=np.array([[1,2,3],[-1,-2,-3]]) print(mat) . [[ 1 2 3] [-1 -2 -3]] . &quot;on ajoute des étiquettes pour clarifier. On utiliser la bibliothèque pandas pour cela.&quot; import pandas as pd df=pd.DataFrame(mat,index=[&quot;i=0&quot;,&quot;i=1&quot;],columns=[&quot;j=0&quot;,&quot;j=1&quot;,&quot;j=2&quot;]) df . j=0 j=1 j=2 . i=0 1 | 2 | 3 | . i=1 -1 | -2 | -3 | . print(&quot;sum_ij mat[i,j]: n&quot;,np.sum(mat)) print(&quot;sum_i mat[i,j]: n&quot;,np.sum(mat,axis=0)) print(&quot;sum_j mat[i,j]: n&quot;,np.sum(mat,axis=1)) . sum_ij mat[i,j]: 0 sum_i mat[i,j]: [0 0 0] sum_j mat[i,j]: [ 6 -6] . v1=np.array([10,20,30]) v2=np.array([100,200,300]) print(&quot;empilons le long de i: n&quot;,np.stack([v1,v2],axis=0)) print(&quot;empilons le long de j: n&quot;,np.stack([v1,v2],axis=1)) . empilons le long de i: [[ 10 20 30] [100 200 300]] empilons le long de j: [[ 10 100] [ 20 200] [ 30 300]] . mat=np.array([[1,2,3],[-1,-2,-3]]) print(&quot;mat: n&quot;,mat) mat2=np.array([[10,20],[30,40]]) print(&quot;mat2: n&quot;,mat2) print(&quot;concaténons en ralongeant l&#39;axe des j: n&quot;,np.concatenate([mat,mat2],axis=1)) . mat: [[ 1 2 3] [-1 -2 -3]] mat2: [[10 20] [30 40]] concaténons en ralongeant l&#39;axe des j: [[ 1 2 3 10 20] [-1 -2 -3 30 40]] . Dans l&#39;exemple précédent, on n&#39;aurait pas pu concaténer avec axis=0. On aurait eu le message d&#39;erreur: all the input array dimensions except for the concatenation axis must match exactly . print(&quot;max_j mat[i,j]: n&quot;,np.max(mat,axis=1)) print(&quot;argmax_j mat[i,j]: n&quot;,np.argmax(mat,axis=1)) . max_j mat[i,j]: [ 3 -1] argmax_j mat[i,j]: [2 0] . Attention, quand on ne précise pas les axes, l&#39;opération par défaut n&#39;est pas toujours très claire: c&#39;est parfois axis=0 ou c&#39;est parfois &quot;celon tous les axes&quot; comme np.sum. . Reshape . a=np.arange(0,12,1) print(&quot;a: n&quot;,a) print(&quot;a.reshape([2,6]): n&quot;,a.reshape([2,6])) &quot;le -1 signifie: &#39;adapte la dimension&#39; &quot; print(&quot;a.reshape([2,-1)]): n&quot;,a.reshape([2,-1])) print(&quot;a.reshape([2,2,3]): n&quot;,a.reshape([2,2,3])) . a: [ 0 1 2 3 4 5 6 7 8 9 10 11] a.reshape([2,6]): [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11]] a.reshape([2,-1)]): [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11]] a.reshape([2,2,3]): [[[ 0 1 2] [ 3 4 5]] [[ 6 7 8] [ 9 10 11]]] . mat=np.array([[1,2,3],[-1,-2,-3]]) print(&quot;mat: n&quot;,mat) print(&quot;mat: n&quot;,mat.reshape([-1])) . mat: [[ 1 2 3] [-1 -2 -3]] mat: [ 1 2 3 -1 -2 -3] . Broadcasting . Le broadcasting c&#39;est le fait de faire des opérations entre tenseurs de shape différentes. C&#39;est une opération que l&#39;on fait naturellement en math, par exemple quand on écrit: $$ sum_j mat[i,j] , vec[j] $$ . np.random.seed(0) # 1 - 4, 1-3, 2 A = np.random.randint(0, 10, [2, 3]) B = np.ones((2,3)) . A . array([[5, 0, 3], [3, 7, 9]]) . B . array([[1., 1., 1.], [1., 1., 1.]]) . A + B . array([[ 6., 1., 4.], [ 4., 8., 10.]]) . v=np.array([1,10]) &quot;transformons `v` en matrice colonne, observons le à côté de la matrice `mat` &quot; vv=v.reshape([2,1]) print(vv) print(mat) . [[ 1] [10]] [[ 1 2 3] [-1 -2 -3]] . &quot; on les multiplie ensemble: &quot; print(vv*mat) . [[ 1 2 3] [-10 -20 -30]] . Ainsi on a répéter la matrice vv trois fois en colonne avant de le multiplier terme à terme. C&#39;est encore plus naturel si on utilise la syntaxe avec newaxis (qui fait la même chose que le reshape précédent). . &quot;calculons : v[i]*mat[i,j]&quot; print(v[:,np.newaxis]*mat) . [[ 1 2 3] [-10 -20 -30]] . A vous: En utilisant le broadcasting, calculez $(2 heartsuit)$ le produit matriciel w . mat avec w = np.array([0,10]). . Même si on n&#39;aime pas faire du broadcasting, quand on récupère du code sur internet, on peut tomber dessus: et parfois il est caché! . &quot;cas élémentaire: ajout d&#39;un scalaire à une matrice: le scalaire est répété&quot; mat=np.array([[1,2,3],[-1,-2,-3]]) print(&quot;mat: n&quot;,mat) print(&quot;mat+3: n&quot;,mat+3) . mat: [[ 1 2 3] [-1 -2 -3]] mat+3: [[4 5 6] [2 1 0]] . vec=np.array([0,10,-10]) print(&quot;vec: n&quot;,vec) print(&quot;mat+vec: n&quot;,mat+vec) . vec: [ 0 10 -10] mat+vec: [[ 1 12 -7] [ -1 8 -13]] . A vous: $(1 heartsuit)$ Qu&#39;elle extention est-elle fait par défaut? Changez vec=np.array([0,10,-10]) en vec=np.array([0,10]), lissez le message d&#39;erreur. . Modifier un tenseur . Directement . vec = np.array([1., 2, 3, 4]) mat = np.array([[1., 2], [3, 4]]) &quot;&quot;&quot;modifier un élément&quot;&quot;&quot; vec[0] = 10. # la numérotation commence à zéro mat[1, 1] = 10. &quot;&quot;&quot; attention, on a ainsi modifier les objets initiaux&quot;&quot;&quot; print(&quot;vec et mat après modification&quot;) print(vec) print(mat) &quot;&quot;&quot;modifier un bloc d&#39;élément&quot;&quot;&quot; vec_zero = np.zeros(shape=[5]) vec_zero[0:3]=5 # [0:3] indique les indices dans l&#39;intervalle [0,3[ mat_un = np.ones(shape=[5, 4]) mat_un[0:2,0:3]=7 print(&quot; nvec_zero n&quot;, vec_zero) print(&quot; nmat_un n&quot;, mat_un) . vec et mat après modification [10. 2. 3. 4.] [[ 1. 2.] [ 3. 10.]] vec_zero [5. 5. 5. 0. 0.] mat_un [[7. 7. 7. 1.] [7. 7. 7. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.]] . Via une &#39;vue&#39; sur les donn&#233;es $ sharp$ . Attention, on touche ici à une des grandes difficultés de numpy; difficulté qu&#39;on retrouve partout en informatique: le passage de données par copie ou par référence. . mat_un = np.ones(shape=[5, 4]) part=mat_un[0:2, 0:3] &quot;&quot;&quot;toute la partie est mise à 7&quot;&quot;&quot; part[:,:]=7 &quot;&quot;&quot;et là, observez : c&#39;est à la fois logique et surprenant:&quot;&quot;&quot; print(&quot; n mat_un n&quot;, mat_un) print(&quot; n part n&quot;, part) . mat_un [[7. 7. 7. 1.] [7. 7. 7. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.]] part [[7. 7. 7.] [7. 7. 7.]] . Comment ça marche : . mat_un = np.ones(shape=[5, 4]) . L&#39;ordi crée un tableau dans la mémoire de l&#39;ordinateur. la variable &#39;mat_un&#39; est une vue (=référence) sur ce tableau. . part=mat_un[0:2, 0:3] . la variable &#39;part&#39; est une vue sur une partie de ce tableau en mémoire. en effectuant : . part[:,:]=7 . on modifie une partie du tableau en mémoire. . Par contre quand on fait : . a=mat_un[0,0] . la variable a contient une copie du coefficient mat_un[0,0]. Modifier a ne modifie pas le tableau en mémoire. La preuve : . mat_un = np.ones(shape=[5, 4]) a=mat_un[0,0] a=7 print(&#39;a=&#39;,a) print(&quot; n mat_un n&quot;, mat_un) . a= 7 mat_un [[1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.]] . Exo . Que sont les tenseurs a,b,c,.... ci-dessous $(4 diamondsuit)$? Mettez la réponse sur papier, avant de vérifier avec un print print. Tachez de distinguer la matrice ligne [[1,2,3]] du vecteur [1,2,3], le scalaire 3 au vecteur [3] etc. . &quot;&quot;&quot;remplissons une matrice par une double boucle&quot;&quot;&quot; nbLigne = 3 nbColonne = 4 mat = np.empty([nbLigne, nbColonne],dtype=np.int64) for i in range(nbLigne): for j in range(nbColonne): mat[i, j] = i + j print(&quot; nmat n&quot;,mat) a = mat[0, :] aBis = mat[0:1, :] b = mat[:,0] c = mat[:, nbColonne - 1] d = mat[:, - 1] # ça: c&#39;est idem que la ligne précédente e = mat[-1,-1] f = mat[0:2,:] g = mat[0:2, 0:1] . mat [[0 1 2 3] [1 2 3 4] [2 3 4 5]] . S&#233;lection par valeurs . Via les tableaux de bool&#233;ens . a=np.array([0.,1.,2,3,4,-1]) print(a) print(a&lt;0) print(a&gt;=0) print(a[a&lt;0]) print(a[a&gt;=0]) print(a[a==0]) &quot;&quot;&quot; le &#39;and&#39; et &#39;or&#39; dans les indices n&#39;est pas le même que les &#39;and&#39; et &#39;or&#39; classiques&quot;&quot;&quot; print(a[(a&gt;0)&amp;(a&lt;4)]) print(a[(a&gt;0)|(a&lt;4)]) . [ 0. 1. 2. 3. 4. -1.] [False False False False False True] [ True True True True True False] [-1.] [0. 1. 2. 3. 4.] [0.] [1. 2. 3.] [ 0. 1. 2. 3. 4. -1.] . Contrairement à la selection par indice (ex : a[:,2]), la selection par valeur créer une &quot;copie&quot;, donc préserve l&#39;originale. . a=np.array([0.,1.,2,3,4,-1]) b = a[a &gt;= 0] b[:] = 10 print(&#39;b&#39;,b) &quot;&quot;&quot; &#39;a&#39; n&#39;a pas changé, ouf. &quot;&quot;&quot; print(&#39;a&#39;,a) . b [10. 10. 10. 10. 10.] a [ 0. 1. 2. 3. 4. -1.] . Important: Quand on a un doute sur &#39;copie&#39; ou &#39;référence&#39;, on teste, comme ci-dessus. . Via des conditions . Pour sélectionner des éléments dans un tableau selon un critère complexe, il faut faire une boucle, et utiliser une liste car on ne sait jamais combien d&#39;élément on va sélectionner à l&#39;avance. . nbSimu=1000 a=np.random.randint(0,100,nbSimu) res=[] for i in range(nbSimu): if a[i]%3==0 and a[i]%7==0: res.append(a[i]) &quot;&quot;&quot;à la fin, on repasse le résultat en tableau numpy&quot;&quot;&quot; res=np.array(res) print(res) . [21 0 0 42 0 42 84 0 42 21 0 0 42 21 84 0 84 21 0 63 63 42 0 84 0 42 63 0 84 84 0 21 0 0 21 21 42 63 84 42 0 0 21 63 0 84 0 63 21] . Alg&#232;bre lin&#233;aire $ flat$ . Attention, en numpy les vecteurs, les matrices lignes et les matrices colonnes sont des objets différents: . vecteur.shape = (?) | matrice_ligne.shape = (1,?) | matrice_colonne.shape = (?,1) | matrice_quelconque.shape = (?,?) | . Observez bien les sorties consoles: les vecteurs s&#39;écrivent avec 1 crochet, les matrices avec 2 crochets. . Multiplication matricielle . np.matmul() s&#39;applique uniquement entre matrices. . size=3 mat_col=np.ones(shape=[size,1]) mat_lin=np.ones(shape=[1,size]) mat_square=np.ones(shape=[size,size]) print(&quot;mat_col n&quot;,mat_col) print(&quot;mat_lin n&quot;,mat_lin) print(&quot;mat_square n&quot;,mat_square) print(&quot;mat_square . mat_col n&quot;,np.matmul(mat_square,mat_col) ) print(&quot;mat_lin . mat_square n&quot;,np.matmul(mat_lin,mat_square)) print(&quot;mat_lin . mat_square . mat_col n&quot;, np.matmul(np.matmul(mat_lin,mat_square),mat_col)) . mat_col [[1.] [1.] [1.]] mat_lin [[1. 1. 1.]] mat_square [[1. 1. 1.] [1. 1. 1.] [1. 1. 1.]] mat_square . mat_col [[3.] [3.] [3.]] mat_lin . mat_square [[3. 3. 3.]] mat_lin . mat_square . mat_col [[9.]] . sinon on peut utiliser np.dot() qui permet les multiplications matrice $ times$ vecteur, matrice $ times$ matrice, vecteur $ times$ vecteur (=produit scalaire) . size=3 vec0=np.ones(shape=[size]) vec1=2*np.ones(shape=[size]) mat_square=np.ones(shape=[size,size]) print(&quot;vec0 . vec1 n&quot;,np.dot(vec0,vec1)) print(&quot;vec0 . mat_square n&quot;,np.dot(vec0,mat_square)) print(&quot;mat_square . vec0 n&quot;,np.dot(mat_square,vec0)) print(&quot;mat_square . mat_square n&quot;,np.dot(mat_square,mat_square)) . vec0 . vec1 6.0 vec0 . mat_square [3. 3. 3.] mat_square . vec0 [3. 3. 3.] mat_square . mat_square [[3. 3. 3.] [3. 3. 3.] [3. 3. 3.]] . et si vous avez python 3.5+, vous pouver utilisez l&#39;opérateur @ qui rend les codes plus lisibles . print(&quot;vec0 @ vec1 n&quot;,vec0 @ vec1) print(&quot;vec0 @ mat_square n&quot;,vec0 @ mat_square) print(&quot;mat_square @ vec0 n&quot;,mat_square @ vec0) print(&quot;mat_square @ mat_square n&quot;,mat_square @ mat_square) . vec0 @ vec1 6.0 vec0 @ mat_square [3. 3. 3.] mat_square @ vec0 [3. 3. 3.] mat_square @ mat_square [[3. 3. 3.] [3. 3. 3.] [3. 3. 3.]] . Exo: Multipliez $(2 heartsuit)$ matriciellement des matrices de taille non-compatible. Extrayez la partie intéressante du message d&#39;erreur. . Inverse et transpos&#233;e . Notez que le pseudo-inverse permet d&#39;inverser les matrices non-inversibles (testez). . size=3 mat=np.zeros(shape=[size,size]) for i in range(size): mat[i,i]=1 mat[0,size-1]=2 print(&quot;mat n&quot;,mat ) print(&quot;mat^T n&quot;,mat.T) print(&quot;mat^(-1) n&quot;,np.linalg.inv(mat)) print(&quot;mat^(-1)-pseudo-inverse n&quot;,np.linalg.pinv(mat)) . mat [[1. 0. 2.] [0. 1. 0.] [0. 0. 1.]] mat^T [[1. 0. 0.] [0. 1. 0.] [2. 0. 1.]] mat^(-1) [[ 1. 0. -2.] [ 0. 1. 0.] [ 0. 0. 1.]] mat^(-1)-pseudo-inverse [[ 1. 0. -2.] [ 0. 1. 0.] [ 0. 0. 1.]] . Vecteur propre et valeur propre . Souvenez-vous qu&#39;en anglais valeur/vecteur &#39;propre&#39; c&#39;est &#39;eigen&#39; value/vector . size=4 &quot;&quot;&quot;une matrice aléatoire auquel on fait subir une opération de normalisation (laquelle?)&quot;&quot;&quot; mat=np.random.uniform(low=0,high=10,size=[size,size]) rowSum=np.sum(mat,axis=1) &quot;&quot;&quot; mat[i,j]=mat[i,j]/rowSum(i) &quot;&quot;&quot; for i in range(size): mat[i,:]/=rowSum[i] eigVal,eigVec=np.linalg.eig(mat) print(&quot; nmat n&quot;, mat ) print(&quot; neigVal n&quot;,np.real(eigVal)) print(&quot; neigVec n&quot;, np.real(eigVec)) . mat [[0.159 0.757 0.008 0.076] [0.297 0.184 0.046 0.473] [0.423 0.128 0.223 0.226] [0.315 0.599 0.062 0.025]] eigVal [ 1. 0.151 -0.139 -0.422] eigVec [[-0.5 0.172 -0.717 0.658] [-0.5 0.009 0.254 -0.532] [-0.5 -0.985 0.612 -0.435] [-0.5 -0.012 0.217 0.31 ]] . A vous: . Pour la mat précédent: pourquoi 1 est-il valeur propre $(2 heartsuit)$? Quel est le vecteur propre associé $(1 heartsuit)$? . | np.linalg.eig donne-t-il les vecteurs propres à droite ou à gauche $(1 heartsuit)$? Sont-ils disposés en ligne ou bien en colonne $(1 heartsuit)$? . | De manière générale, toutes les matrices sont-elles diagonalisables $(1 heartsuit)$? A quoi servent les np.real() dans le programme précédent $(1 heartsuit)$? . | laquelle de ces deux formules est la bonne $(1 heartsuit)$? . Diag = P^-1 @ mat @ P . | . ou . Diag = P @ mat @ P^-1 . Vérifiez avec python. Aide: Pour transformez un vecteur en matrice diagonale, utilisez np.diag(vecteur) . Application : loi forte des grands nombres . Illustration graphique . Théorème: Soit $(X_n)$ une suite de v.a, qui admet une espérance, on a: $$ lim_n frac 1 n (X_0+....+X_{n-1}) = mathbf E[X_0] $$ . Remarque : pour illustrer ce théorème, on va tracer la courbe $$ n to frac 1 n (X_0+....+X_{n-1}) $$ mais on n&#39;est pas obligé de l&#39;évaluer pour tous les $n$ (ex: on peut aller par pas de 40) . import matplotlib.pyplot as plt % matplotlib inline &quot;&quot;&quot; np.arange c&#39;est comme range() sauf que cela donne un tableau numpy&quot;&quot;&quot; n_max=10000 ns=np.arange(10,n_max,40) means=[] for n in ns: simus=np.random.uniform(0,10,size=n) means.append(np.mean(simus)) fig,ax=plt.subplots() ax.plot(ns,means) ax.plot([0,n_max],[5,5]); . A vous: $(3 heartsuit)$ J&#39;ai volontairement fait une erreur dans le programme précédent, une erreur que font beaucoup d&#39;étudiant chaque année. Relisez attentivement la loi des grands nombre, comparez cet énoncé avec le programme ci-dessus. Trouvez le bug. . Illustration num&#233;rique . nbSimu = 10000 &quot;&quot;&quot;un échantillon de va de loi uniforme sur [0,1]&quot;&quot;&quot; X1 = np.random.random(size=nbSimu) &quot;&quot;&quot; un échantillon de va de loi normale (=gaussienne), centrée réduite par défaut. &quot;&quot;&quot; X2 = np.random.normal(size=nbSimu) &quot;&quot;&quot; un échantillon de va de loi de Poisson&quot;&quot;&quot; X3 = np.random.poisson(1, size=nbSimu) print(len(X1[X1&lt;0.7])/nbSimu,&quot;valeur attendue:&quot;,0.7) print(sum( (X1-0.5)**2)/nbSimu,&quot;valeur attendue:&quot;,1/12) print(len(X2[X2&lt;0.])/nbSimu,&quot;valeur attendue:&quot;,0.5) . 0.6973 valeur attendue: 0.7 0.08348008125317427 valeur attendue: 0.08333333333333333 0.4996 valeur attendue: 0.5 . Donnez ci-dessus les valeurs attendue, et révisez ainsi votre loi de Poisson $(3 times 1 heartsuit)$. . print(np.sum(X2**2)/nbSimu,&quot;valeur attendue:&quot;) print(len(X3[X3==3])/nbSimu,&quot;valeur attendue:&quot;) print(len(X3[X3!=0])/nbSimu,&quot;valeur attendue:&quot;) . 0.9944552041938416 valeur attendue: 0.0644 valeur attendue: 0.6375 valeur attendue: . Monte carlo . A vous: à l&#39;aide de variables uniformes, en utilisant la loi forte des grands nombres, estimez $(3 times 2 heartsuit)$ les intégrales suivantes: $$ int_0^1 x dx qquad text{et} qquad int_0^{ frac 12 } frac x { ln(x)} dx qquad text{et} qquad int_0^1 frac 1 x dx $$ Cette méthode pour calculer des intégrales est appelée : Méthode de Monte Carlo . Application : moyenne et &#233;cart-type . Simulons des échantillons: . nbData=100 X1=np.random.random(size=nbData) X2=np.random.normal(size=nbData); . calculons leur moyenne, qu&#39;on peut appeler : mu_hat (mu pour espérance, et hat pour estimation) | calculons leur écart type empirique : sigma_hat | . print(&quot;loi uniforme sur [0,1]&quot;) print(&quot;* mu_hat&quot;,X1.mean()) print(&quot;* sigma_hat&quot;,X1.std()) print(&quot;loi normale&quot;) print(&quot;* mu_hat&quot;, X2.mean()) print(&quot;* sigma_hat&quot;, X2.std()) . loi uniforme sur [0,1] * mu_hat 0.5024284976752623 * sigma_hat 0.29961441559030433 loi normale * mu_hat 0.011267812839176015 * sigma_hat 1.0073665045190698 . A l&#39;aide des estimateurs, vérifiez expérimentallement les résultats suivants $(4 times 2 heartsuit)$: . l&#39;espérance de la somme de deux variables aléatoires c&#39;est la somme des espérances. | la variance de la somme de deux variables aléatoires indépendantes c&#39;est ... | soient $X$ une v.a, $a$ et $b$ des constantes. On a: $ mathbf V[aX+b]= ...$. | L&#39;espérance du carré d&#39;une v.a est toujours plus... que le carré de l&#39;espérance. | . Numpy or not numpy . Quand on écrit un programme il faut toujours se demander si on va utiliser des tenseurs numpy ou pas. Par exemple, considérons la fonction suivante: . def f(x): return x**2*(1-x)**2+1 . Cette fonction fonctionne (!) pour x scalaire, mais aussi pour x tenseur: car les opérations puissance **, somme + et produit * sont bien définies sur les tenseurs. Ainsi on peut tracer le graphe de f de deux manières différentes: . &quot;&quot;&quot;première méthode&quot;&quot;&quot; xs=np.linspace(0,1,100) ys=[] for x in xs: ys.append(f(x)) plt.plot(xs,ys); . &quot;&quot;&quot; seconde méthode&quot;&quot;&quot; plt.plot(xs,f(xs)); . La seconde méthode est plus élégante mais aussi beaucoup plus rapide. . Par contre, considérons la fonction: . def g(x): if 0&lt;x&lt;0.5: return x elif 0.5&lt;x&lt;2: return 2*x else : return 0 . Cette fonction g ne fonctionne pas quand x est un tenseur numpy (essayez $(1 heartsuit)$, observez le message d&#39;erreur, vous le rencontrerez sans doute plus tard). On peut transformer cette fonction pour quelle marche avec numpy mais c&#39;est un peu technique. . Le conseil: dans un premier temps, ne vous prenez pas trop la tête. Faites au plus simple même si ce n&#39;est pas le plus performant. Vous apprendrez les astuces au fur et à mesure. . Sous le capot de numpy $ flat$ . Des donn&#233;es &#224; plats. . Peu importe la shape ou le dtype (=data_type): dans la mémoire, les tableaux numpy sont stockés sous la forme d&#39;un tableau 1D, par paquets-de-8bits. Quand vous changer la shape, les données ne change pas du tout, c&#39;est uniquement la façon de les parcourir qui change. . &quot; ces 4 objets sont associées aux même données toutes plates.&quot; vec=np.arange(0,9,1) print(&quot;vec n&quot;,vec) mat_square=vec.reshape([3,3]) print(&quot;mat_square n&quot;,mat_square) mat_col=mat_square.reshape([9,1]) print(&quot;mat_col n&quot;,mat_col) mat_line=mat_square.reshape([1,9]) print(&quot;mat_line n&quot;,mat_line) . vec [0 1 2 3 4 5 6 7 8] mat_square [[0 1 2] [3 4 5] [6 7 8]] mat_col [[0] [1] [2] [3] [4] [5] [6] [7] [8]] mat_line [[0 1 2 3 4 5 6 7 8]] . l&#39;attribut &#39;strides&#39; . Quand on change la shape, on chage aussi l&#39;attribut strides: il indique comment on passe d&#39;une case à l&#39;autre. . ex: vecteur . Dans ce cas, strides est un scalaire: il indique de combien de paquet-de-8bits il faut glisser pour aller de vec[i] à vec[i+1]. Cela dépend uniquement du dtype . a=np.zeros(shape=5,dtype=np.uint8) print(&quot;np.uint8, strides:&quot;,a.strides) a=np.zeros(shape=5,dtype=np.int32) print(&quot;np.int32, strides:&quot;,a.strides) a = np.zeros(shape=5, dtype=np.int64) print(&quot;np.int64, strides:&quot;,a.strides) . np.uint8, strides: (1,) np.int32, strides: (4,) np.int64, strides: (8,) . ex: matrice . Dans ce cas, strides est une paire. . strides[0] indique de combien de paquet-de-8bits il faut glisser pour passer de la case mat[i,j] à la case mat[i+1,j] | strides[1] indique de combien de paquet-de-8bits il faut glisser pour passer de la case mat[i,j] à la case mat[i,j+1] | . Illustrons cela avec uniquement dtype=np.uint8. . a = np.zeros(shape=(2,4), dtype=np.uint8) print(&quot;shape=(2,4), strides:&quot;, a.strides) a = np.zeros(shape=(30, 5), dtype=np.uint8) print(&quot;shape=(30,4), strides:&quot;, a.strides) . shape=(2,4), strides: (4, 1) shape=(30,4), strides: (5, 1) . A vous: Essayez de répondres à ces 3 questions sans faire de print $(3 diamondsuit)$ puis avec un print $(3 heartsuit)$. . quelle est la stride de np.zeros(shape=(2,4), dtype=np.int32) | quelle est la stride de np.zeros(shape=(30,5), dtype=np.int32) | A quoi correspond la stride d&#39;un tenseur de dimension 3. | .",
            "url": "https://oh-ce-cours.github.io/2021_polytech_gis4_AL_rapports/2021/06/17/blog1.html",
            "relUrl": "/2021/06/17/blog1.html",
            "date": " • Jun 17, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Article de test",
            "content": "A propos . Mon premier article de blog avec fastpages . import numpy as np import matplotlib.pyplot as plt . xs = np.linspace(-10, 10, 1000) ys = np.cos(xs ** 2) plt.plot(xs, ys) . [&lt;matplotlib.lines.Line2D at 0x16d7da79d30&gt;] .",
            "url": "https://oh-ce-cours.github.io/2021_polytech_gis4_AL_rapports/data-science/2021/06/16/er-article.html",
            "relUrl": "/data-science/2021/06/16/er-article.html",
            "date": " • Jun 16, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://oh-ce-cours.github.io/2021_polytech_gis4_AL_rapports/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://oh-ce-cours.github.io/2021_polytech_gis4_AL_rapports/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://oh-ce-cours.github.io/2021_polytech_gis4_AL_rapports/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}